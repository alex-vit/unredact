---
name: go
description: Go (Golang) patterns and knowledge for Windows-first development
disable-model-invocation: true
---

# Go Patterns & Knowledge

## Constraints

- Avoid CGO. If a dependency requires CGO, ask before using it.
- Don't strive for the latest Go version or features unless there's good reason. If unsure about a newer API or language feature, say so rather than guessing. Check `go.mod` for the actual version in use.

## Code Style

- Prefer `max()`/`min()` builtins over `if` + clamp patterns. E.g. `nearest = max(nearest, 10)` not `if nearest < 10 { nearest = 10 }`.
- Rename functions when names get too similar but do different things. E.g. `autostartEnable`/`autostartEnabled` → `autostartEnable`/`isAutostartEnabled`.

## Goroutines & Functions

- Use range-over-int: `for i := range 3` not `for i := 0; i < 3; i++` (Go 1.22+).
- Extract non-trivial goroutine bodies into named functions: `go autoUpdate()` not `go func() { ... }()`. Keeps the call site readable and the function testable. Place the extracted function in the file that owns its domain (e.g. update logic in `update.go`, not `main.go`).

## Code Maintenance

- Use `go fix ./...` to auto-apply migrations and modernize code (e.g. adopting new stdlib APIs, range-over-int, etc.).
- Use `goimports -w .` to format code, add missing imports, and remove unused ones in one pass. Run this after significant edits (new files, renamed packages, bulk changes).

## Building

- Standard checks: `go test ./...` and `go vet ./...`
- Windows GUI app (no console window): `-ldflags "-H=windowsgui"`
- Inject version: `-ldflags "-X main.version=1.0.0"`
- Combined: `go build -ldflags "-X main.version=1.0.0 -H=windowsgui" -o app.exe ./cmd/app/`

## Running on Windows

- Kill a running process: `powershell -Command "Stop-Process -Name app -Force -ErrorAction SilentlyContinue"`
- Launch detached (non-blocking): `start app.exe`

## Pattern: go:generate

Use `go:generate` for self-contained code/asset generation with zero external tools. The generated output is committed so builds don't require regeneration.

### Build tag

- `//go:build ignore` — use when the generator is in a different package (e.g. `internal/icon/gen_icon.go` with `package main` inside a `package icon` directory)
- `//go:build generate` — use when the generator is in the same package as the rest of the code (e.g. `gen_languages.go` with `package main` in a `package main` directory)

### Variant A: generate + embed (binary assets)

For binary files (icons, images, data) embedded into the binary at compile time.

```
pkg/
  gen_asset.go    # generator (//go:build ignore, package main)
  asset.go        # //go:generate + //go:embed wrapper
  output.bin      # generated file (committed)
```

```go
// asset.go
//go:generate go run gen_asset.go
package pkg

import _ "embed"

//go:embed output.bin
var Data []byte
```

Real example: monibright `icon/` — `gen_icon.go` generates a multi-size .ico from pure Go (image/png + hand-rolled ICO format).

### Variant B: generate Go source (code generation)

For generating `.go` files — fetching data from APIs, building lookup tables, etc.

```
project/
  gen_thing.go    # generator (//go:build generate, same package)
  thing.go        # generated Go source (committed)
```

Key points:
- Use `go/format` to produce clean, gofmt'd output
- Use `text/template` for the generated file structure
- Add a `// File generated by gen_thing.go; DO NOT EDIT.` header
- The `//go:generate` directive goes in the generator itself

Real example: wt `gen_languages.go` — fetches Wikipedia's language list from the sitematrix API, generates a Go map of supported language codes.
